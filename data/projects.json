{
    "projects": [
        {
            "name": "Ninjas on Trampolines",
            "description": "üèÜ<b>Best Experimental Game at RIT EDGE</b>üèÜ<br>A Platform Fighter That Relies on Physics-Based Trampolines.",
            "coverImage": "media/ninjas/ninjas.gif",
            "icon": "media/ninjas/ninjas_icon.jpg",
            "trailerEmbed": "https://www.youtube.com/embed/npBA1ONB4aw?autoplay=1",
            "role": "<lead-programmer></lead-programmer> / <systems-designer></systems-designer>",
            "teamSize": "7",
            "engine": "Unity",
            "tools": "C#, Python, Git, Gimp, Mirror Library, Unity Profiling",
            "duration": "August 2023 - Present",
            "docs": "https://docs.google.com/document/d/1VzbaXHNuhw9445c2Qm5PXf4R0Jn5yNRlm7IDgVhKtI4/edit#heading=h.qyxnk3d3ngnk",
            "overview": "Ninjas on Trampolines is a physics-based platform fighter where players play as Ninjas that can paint their own colors on the wall. The objective of the game is to have the most of your own color on the back wall by the end of a match, which can be done by smacking other players or using a spray can to graffiti the background.<br><n-tab></n-tab>The game features three different game modes: Free-for-All, Spray King, and Paintball. Each gamemode takes a twist on the simple, yet extremely captivating game loop of Free-for-All by introducing new objectives for players. Paintball has players chase a soccer ball-like object, while Spray King has players chase another player holding an item that gives them an advantage.",
            "goals": [
                "To create a simple and captivating game loop.",
                "Improve my knowledge of implementing physics in games.",
                "Optimize our codebase and shaders to minimize latency.",
                "To experiment with multiplayer backends and networking solutions.",
                "Have a game that I am proud to publish on a digital store."
            ],
            "responsibilities": "During the first few months of development, my main priorities were in the area of developing systems for the game, including player mechanics, trampoline physics, paint score calculations, and creating data structures to store player data.<br><n-tab></n-tab>For player physics, I ended up utilizing Unity's in-built rigidbodies and heavily modifying their physics to create fast-paced, yet still controllable, movement. This was done by introducing a dozen or so parameters housed in two C# scripts, which would tweak various aspects of how the player moved and how they would react to physics events. I spent a few weeks tweaking these scripts to get players moving exactly how our team wanted them to. <br><n-tab></n-tab>I further incorporated physics into the project by working on trampoline physics, which uses a combination of forces and joints to simulate the contour of a real trampoline. The trampolines have gone through multiple code refactors and design changes, mostly due to technical constraints imposed by how they were constructed. At first, I utilized a grid of box colliders, stacked vertically, that would contour downward if a player stepped on one of them, and spring back when the player stepped off of it. This had a few major technical faults: <br><ol><li>Diagonal construction was not possible due to Unity's inability to freeze local physics constraints.</li><li>Trampolines were not contouring correctly; only a small portion of the whole trampoline was being simulated.</li><li>The trampolines were unoptimized and required unnecessary physics checks due to the colliders not acting as a complete system. </li></ol><n-tab></n-tab>Our current trampolines have colliders that are conjoined to each other, and have several optimizations to reduce the amount of physics checks that they endure. For one, if no entities are near the trampoline, it will completely ignore any checks. Along with this, I cut down the number of required box colliders to <b>half or lower</b> of what it was before, as the colliders now work in unison using joints.<br><n-tab></n-tab>Other than players and trampolines, I worked on data structures to allow local multiplayer functionality, with the ability to store unique player IDs and colors that can be transferred between scenes. This is derived from a player select menu, which registers player input devices when they press a button on a peripheral.<br><n-tab></n-tab>I also worked on paint scoring, which is done through a paint shader programmed in HLSL, <a href='https://en.wikibooks.org/wiki/Cg_Programming/Unity/Computing_Color_Histograms'>deriving from a histogram algorithm that tracks red/green/blue levels of color in a given texture.</a> <br><n-tab></n-tab>This led us to an MVP (Minimum Viable Product) of the project, which we submitted to RIT's MAGIC Maker program and got accepted into.<br><n-tab></n-tab>During the MAGIC Maker program, I was tasked to work on more backend systems for the game as well as integrating networking functionality to allow for online play. During this time, I also made several optimizations to shader functionality, improving the frame rate of the game by around 2.5 times (from ~80FPS with stutters to a steady 250FPS). I also wrote a Python script that was used for player telemetry, generating heatmaps based on position data that would be used to optimize our level design.<br><n-tab></n-tab>For the majority of the program, I was in charge of converting our local multiplayer systems to ones that are able to be networked through Steam. I ended up choosing Mirror as our networking solution, mainly because it provided solutions for server authoritative functionality. Most of the game, as it is networked currently, sends all logic to a centralized server for it to be processed. However, I had to stray away from developing our movement system to be server authoritative for a few reasons: <br><ol><li>Server authoritative movement, without a prediction algorithm, has a lot of latency.</li><li>Our game, being reliant on Unity's 2D physics engine, did not have an easy way to implement a <a href='https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html'>client-side prediction (CSP)</a> algorithm without us needing to completely rewrite all physics.</li></ol><n-tab></n-tab>I ended up rewriting our movement logic to work with client authority in mind, as needing to completely rewrite my physics system was out of scope. This poses some minor issues with syncing positions between clients, but it shouldn't be too egregious unless the game is running at high latency. <br><n-tab></n-tab>Currently, Ninjas on Trampolines can be played online through Steam in the free-for-all game mode, with other game modes and items being worked on as development progresses. Networking will be my final large task until the game releases to Steam, which I am actively working on to provide the best experience possible.<br><br>&emsp;My contributions to Ninjas on Trampolines have garnered us an award, Best Experimental Game at RIT's EDGE Student Showcase, and several nominations at RPI's GameFest for Best Design and Stupid Fun.",
            "retrospect": "   If I were to do this project again, I would write my own physics engine in Unity, both to allow for smoother networking and to have more control over the trampoline physics. These are the two biggest issues that I have dealt with, which took weeks of development time to find solutions for. With more control over my physics, I feel as if these areas of development would be smoother. <br><n-tab></n-tab>Along with this, I would employ better programming standards to myself and my team. Although I remained good at documenting my code through comments, there was confusion with snippets of code that were used universally within the project. Some outside documentation would have helped drastically to solve this issue.",
            "link": "https://store.steampowered.com/app/2893990/Ninjas_on_Trampolines/",
            "photoGallery": [
                {
                    "url": "media/ninjas/ninjas_logo.png",
                    "subtitle": "Logo for Ninjas on Trampolines"
                },
                {
                    "url": "media/ninjas/ninjas_screenshot.png",
                    "subtitle": "Typical Gameplay"
                },
                {
                    "url": "media/ninjas/trampoline_prototype.gif",
                    "subtitle": "First Prototype of Trampolines"
                },
                {
                    "url": "media/ninjas/trampoline-old.gif",
                    "subtitle": "Demonstration of Old Trampolines"
                },
                {
                    "url": "media/ninjas/trampoline-new.gif",
                    "subtitle": "Demonstration of New Trampolines"
                },
                {
                    "url": "media/ninjas/MVP.gif",
                    "subtitle": "Ninjas on Trampolines MVP"
                },
                {
                    "url": "media/ninjas/heatmap.png",
                    "subtitle": "Heatmap Generated Using My Python Script"
                },
                {
                    "url": "media/ninjas/cpu_before.png",
                    "subtitle": "CPU Usage Before My Optimizations (~80-100FPS)"
                },
                {
                    "url": "media/ninjas/cpu_now.png",
                    "subtitle": "CPU Usage After My Optimizations (~250FPS)"
                },
                {
                    "url": "media/ninjas/steam.gif",
                    "subtitle": "Inviting Friends Through Steam"
                },
                {
                    "url": "media/ninjas/award.jpg",
                    "subtitle": "Best Experimental Game at RIT's EDGE Showcase"
                }
            ],
            "color": "#C1424F"
        },
        {
            "name": "Changeling VR",
            "description": "A Virtual Reality Narrative Mystery Experience.",
            "coverImage": "media/changeling/changeling.gif",
            "trailerEmbed": "https://www.youtube.com/embed/nZGJtnUvC2I?autoplay=1",
            "role": "<reg-programmer></reg-programmer> / <ui-designer></ui-designer>",
            "teamSize": "~80",
            "engine": "Unreal Engine 4",
            "duration": "May 2023 - August 2023",
            "tools": "Google Sheets, Google Forms, Perforce, Unreal Engine Blueprints, Android Studio",
            "overview": "Changeling is a VR mystery, first-person 3D platformer game built upon the idea of magical realism and a sense of unease and wonder. You play as Aurelia, a dream-walker who has the ability to see through the eyes of anyone she touches. You are tasked with helping this family figure out what is wrong with their child, and as you contact each member, you see through the lens of their hopes and fears of what the child is. Changeling is developed under Xana Ad Hoc Studio, a studio in Rochester, NY.",
            "goals": [
                "To assist development teams and production leads with technical tasks.",
                "To facilitate building and deploying project builds.",
                "To improve XR interactions."
            ],
            "responsibilities": "I worked to improve team workflow and general functionality of core gameplay mechanics. Notable inclusions that I worked on are the player's physics-based hands and the teleportation system. I also cleaned and optimized many of the files in the project's repository, helped other development teams with their various needs, and facilitated building for crucial project deadlines. <br><n-tab></n-tab>My first responsibility for the project was to rework the teleportation system, as it was barely functional when I entered the project. The portal destination point was incredibly inaccurate, and the line leading from the player to the teleportation circle was jagged and barely readable. To fix this, I simulated the path of a projectile from the player's location to the direction they pointed outwards. Using the points generated, I made a spline and attached meshes to generate a smooth arc. This also made the teleportation more precise, as I could determine the exact point in which the fake projectile would collide with the ground.<br><n-tab></n-tab>One major problem I had with this system, however, was held objects or close-by objects blocking the teleportation spline. This was easily solvable by excluding everything held in the player's hand, and ignoring objects that were too close to the player via distance checks.<br><n-tab></n-tab>My second major responsibility was to improve XR interactions with the player's hands. Before my improvements, the player's hands would phase through objects as if they were intangible. To make the player's hands feel more real, I opted to follow the interaction design of a game like 'Half Life Alyx', where they allow players to physically touch almost everything they are able to see. To do this, I simulated two separate layers for hands: one that represented the real-world location of a player's hand and another to represent the player's physics hand in-game. The physics hand is connected with physics constraints and joints to the real-world location of the player. This is needed because accurate tracking of player hands cannot be done if the object storing the data is also simulating physics. To circumvent this, we simulate physics on another object that is connected to it. <br><n-tab></n-tab>I went to GDC (Game Developers Conference) in 2024, and heard a <a href='https://schedule.gdconf.com/session/future-realities-summit-using-physics-constraints-to-make-intuitive-vr-interactions/901636'>great talk from Antony Stevens about this topic</a>, which covers the process of how I implemented this.<br><n-tab></n-tab>Implementing these physics-based hands was not a straight forward process, however. One of the biggest design considerations I had to worry about was teleportating next to a wall; the player's hands immediately teleport to the player's new location. If one of the hands happens to be through a wall, there would be no way to retrieve it back because it now interacts with the environment. To solve this issue, I created a raytracing system that would scan the area in front of the player whenever they are teleporting. If a wall or obstacle is detected, the physics hand will get the normal vector of the surface the raycast collides with, and teleport right snug against that surface. In practice, this took many attempts to perfect due to how many different kinds of surfaces were in the game, however, I eventually figured out a system that worked universally.<br><n-tab></n-tab>Aside from these bigger tasks, I was responsible for taking requests made by other development teams and trying to fix their problems to the best of my ability. Because of our moderately large development team (around 80 people), I needed to respond to around 2 or 3 different smaller tasks per day. This would require me to talk with the leads of these development teams to access their needs, and I would generally respond with a solution within a few hours. <br><n-tab></n-tab>The most pressing task I was given during my employment happened near the end of my time at Xana Ad Hoc, when we were preparing for the final project build. When I ran said build, it would crash almost immediately, giving a very vague error message. This happened one day before our deadline to submit a final build, which caused some panic amongst the development team. Thankfully, I quickly learned how to use Unreal Engine's build debugging tools, and found that the crash was coming from functions that handled baked lighting. After disabling all of the baked lighting, the build worked perfectly. Because of my efforts, we were able to get a working final build submitted to the higher-ups within the time we had left.",
            "retrospect": "If I were to redo my time on this project, I would try to spend more time trying to unravel some of the older blueprints made by previous teams. The few blueprints that I was able to work on improved drastically, however, there were many that I did not have the time to improve, which will continue to serve as technical debt unless fixed.",
            "link": "https://www.changelingvr.com/",
            "photoGallery": [
                {
                    "url": "media/changeling/box.gif",
                    "subtitle": "Physics-based XR Interactions Demo"
                },
                {
                    "url": "media/changeling/oldTP.png",
                    "subtitle": "Teleportation Code Before My Cleanup and Optimizations"
                },
                {
                    "url": "media/changeling/newTP.png",
                    "subtitle": "Teleportation Code After My Cleanup and Optimizations"
                },
                {
                    "url": "media/changeling/spline.png",
                    "subtitle": "Teleportation Spline and Portal"
                }
            ],
            "color": "#ffe09a"
        },
        {
            "name": "NASA X-Hab Program",
            "description": "A VR/AR Game Made in Collaboration with NASA.",
            "coverImage": "media/nasa/nasa_pushup.gif",
            "trailerEmbed": "https://www.youtube.com/embed/RfQ9nksPhJs?autoplay=1",
            "icon": "media/nasa/xhab.webp",
            "role": "<reg-programmer></reg-programmer>",
            "teamSize": "~25",
            "engine": "Unreal Engine 5",
            "duration": "August 2023 - December 2023",
            "tools": "Unreal Engine Blueprints, Google Workspace, Meta Quest API, Unreal Engine XR API",
            "overview": "This project is funded as a collaboration between NASA and RIT students. It seeks to solve the problem of testing astronaut health in extreme conditions, such as on a different planet, while making the experience entertaining. This project is still ongoing, and does not have a formal name.",
            "goals": [
                "To implement a hand tracking system in Unreal Engine 5 using Meta Quest Devices",
                "To develop a simple prototype of a push-up detection system using hand tracking"
            ],
            "responsibilities": "I was part of this team during the initial development phases, during the fall semester of the 2023 RIT school year. I collaborated with numerous different engineering students of different fields, pitched ideas, with the overall goal to produce a mockup gameplay system for the project.<br><n-tab></n-tab>At first, me and other software developers were tasked to create a 'pegboard' game where astronauts needed to hang from a wall. I created multiple documents and proposals for this idea and started working on a rough prototype of the ideas. <br><n-tab></n-tab>Unfortunately, this idea was cut around half way into my time on this project, mostly due to size constraints. I then had to make completely new development and design documents to show to the other engineers for the new, and current, 'push-up' system. After the ideas were approved by the engineers, and by those at NASA, I started work again on a rough prototype. All the planning for this project took the majority of the semester, and left me with two weeks to complete this prototype. ",
            "link": "https://www.rit.edu/imagine/exhibits/integration-gamification-and-ideis-enable-crew-health-and-performance-mars",
            "photoGallery": [
                {
                    "url": "media/nasa/nasa_pushup.gif",
                    "subtitle": "Push up prototype in Unreal Engine 5 using hand tracking"
                }
            ],
            "retrospect": "If I continued development on this project, newer technology to test, like the Meta Quest 3, would have saved me a lot of time. Hand tracking using the Meta Quest or Meta Quest 2 is very primitive, which caused some issues when initially setting up the push-up detection system.",
            "color": "#becbcf"
        },
        {
            "name": "Olympus Interactive Website",
            "description": "A Company Website Created using React/Typescript",
            "coverImage": "media/olympussite/olympussite.gif",
            "role": "<reg-programmer></reg-programmer>",
            "docs": "https://www.figma.com/design/XCSPbh0OkenJu3KeFrE24N/Team-Site?node-id=0-1&t=aBsXCt8YtvNxy0u8-0",
            "teamSize": "2",
            "duration": "August 2024",
            "tools": "Node.js, React, Bootstrap, Webpack, Figma",
            "overview": "This website is a side-project of mine to allow my small group of developers to have a homepage for our work. It was created in my free time in a month's time and was an opportunity for me to further my web development skills with React and TypeScript.",
            "goals": [
                "To improve my skills in web development, specifically using React and TypeScript",
                "To create a homepage for my team, Olympus Interactive."
            ],
            "responsibilities": "I was responsible for most of the development of the page. I implented Node to create a development environment for myself, and utilized React components for the frontend of the site. I helped with design work using Figma, however, I was not the primary designer for the page layout.<n-tab></n-tab>The site is still a work in progress, and will update with more features and improvements as I get time to work on it further.",
            "link": "https://www.olympusinteractive.com/",
            "photoGallery": [
                {
                    "url": "media/olympussite/olympussite_mockup.png",
                    "subtitle": "Initial Mockup of Site Using Figma"
                },
                {
                    "url": "media/olympussite/os_landing.png",
                    "subtitle": "Landing Page"
                },
                {
                    "url": "media/olympussite/os_gamepage.png",
                    "subtitle": "Project Section"
                },
                {
                    "url": "media/olympussite/os_team.png",
                    "subtitle": "Team Section"
                },
                {
                    "url": "media/olympussite/os_contact.png",
                    "subtitle": "Contact Section"
                }
            ],
            "color": "#becbcf"
        },
        {
            "name": "[PROTOTYPE] Pokemon Wordle Game",
            "description": "A Full Stack Web App Using Node, Express, ArangoDB, and React",
            "coverImage": "media/wordle/wordle.gif",
            "role": "<reg-programmer></reg-programmer>",
            "teamSize": "1",
            "duration": "August 2024 - September 2024",
            "tools": "Node, Express, ArangoDB, React, Nginx, Bootstrap, TypeScript, JavaScript",
            "overview": "This is a work in progress application that I have made to learn more about web development. The project is a server-based application that interfaces with a React application. I wanted to create a wordle-like application for some time, and decided to use Pokemon as the basis because I am very familiar with the franchise. A new pokemon is chosen for players every 24 hours (midnight EST), and the goal is to guess the pokemon of the day in six or fewer guesses.",
            "goals": [
                "To improve my skills in web development, specifically backend development using databases and Node applications."
            ],
            "responsibilities": "I was the sole developer of this application. I started with the backend services, creating a Node/Express app that I later hosted on an AWS Ubuntu client, forwarded to my website using Nginx.<n-tab></n-tab><br> One major thing that I learned while making this application is the importance of SSL certificates. Up until I was about to deploy my application, I was reading API calls through the IP address of the web server I hosted my Node application on, which was unsecure. I then had to learn about how to secure this API, and looked into Nginx, which allowed me to alter the DNS settings of my website to provide a secure place for my API to be called. This took a bit of time for me to understand, but I am familiar with the process now. The API is being interfaced from <a href='https://pokemonapi.samichamberlain.com/'>here</a>. <n-tab></n-tab><br> While working on the Node application, I set up an ArangoDB instance on the web server, allowing for entries to be stored and read on clients whenever requested. I was familiar with SQL databases before ArangoDB, which made this transition daunting to start. However, I quickly started to like the structure of ArangoDB; the query language is much like regular programming and having edge documents to represent connections between regular documents made a lot of sense to me compared to SQL databases. I ended up hosting this on the same web server as my Node application, and it has one database that stores the information of Pokemon entries.<br><n-tab></n-tab>Finally, I worked on the frontend as a React/TypeScript project. This is the part that needs the most work, in my opinion. I did not prioritize working on any styling as I wanted to get a minimum viable product running ASAP. As such, most of my steps forward are going to be in the frontend application, trying to improve the user experience of the project as a whole.",
            "link": "./pkmnwordle",
            "photoGallery": [
                {
                    "url": "media/wordle/wordle-ui.png",
                    "subtitle": "Current Frontend Interface"
                }
            ],
            "color": "#becbcf"
        },
        {
            "name": "Nebulicious",
            "description": "A Cooking Simulator Made for Society of Play's Hexcode Jam 3 in Under 10 Days.",
            "coverImage": "media/nebulicious/nebulicious.gif",
            "trailerEmbed": "https://www.youtube.com/embed/CrXL9HJmBng?autoplay=1",
            "docs": "https://docs.google.com/document/d/1Ek1YsNrmnBxao7xPV4B0l6KNCt-yG7aMEzFaVddeYqg/edit?usp=sharing",
            "icon": "media/nebulicious/nebulicious_icon.png",
            "role": "<reg-programmer></reg-programmer> / <game-developer></game-developer>",
            "teamSize": "6",
            "engine": "Unity",
            "tools": "C#, Git, Gimp, Google Workspace",
            "duration": "June 2024 (10 days)",
            "overview": "Nebulicious is a prototype of a casual cooking game with the twist of using two separate movement options to gather ingredients and cook donuts. The project was made for the Society of Play's <a href='https://itch.io/jam/hexcode-jam-3'>Hexcode Jam 3</a>, which required us to use a specific color palette named 'Hot Panda'.",
            "goals": [
                "To learn more about efficient data management in C# and Unity.",
                "To follow the guidelines of the challenge given and produce a high quality program.",
                "To experiment with spherical math, akin to games like 'Mario Galaxy'."
            ],
            "responsibilities": "During the prototype development of Nebulicious, I was responsible for most of the programming in the game. This included player movement and physics, interactables, data structures to store recipes, and spherical math to simulate faux-gravity on a planet. I also contributed to the UI and UX design of the project after I finished my programming responsibilities.<br><n-tab></n-tab>One new trick I implemented in this project was the usage of scriptable objects in Unity. Before this project, I hadn't used this feature too much. I created multiple structs for this game, representing different resource types, machines, and recipes, which were compiled into a scriptable object that anyone could easily change without looking at code. This drastically helped with our game's balance, as other developers could easily change crucial values in only seconds. Using scripable objects has opened my eyes to the potential that they provide, and I will adapt my development habits to include these more often.<br><n-tab></n-tab>Along with this, I tried to keep a clean and flexible codebase for this project, which allowed us to implement multiple different cooking machines and recipes before the 10 day time limit was reached. I utilized inheritance and polymorphism for the cooking stations, which will allow us to easily add new cooking station objects in the future with minimal effort, just requiring us to modify the scriptable object mentioned earlier and attaching a script of the ICookingStation interface to the object. Overall, I am very happy with how the codebase is currently with this project, enough so to want to continue working on it out of a prototype state.<br><n-tab></n-tab>Depending on the reception from this game, I plan to continue working on it sometime in the future. I am very proud of how it turned out, and see the potential in continuing its development.",
            "link": "https://willyjeon.itch.io/nebulicious",
            "retrospect": "If I had another chance to make this game, I would have given myself more breaks. Our idea was very ambitious for a 10 day time limit, which caused me to work very hard on getting the core mechanics finished on time for the other developers. This led to me feeling burnt out near the end of the time limit, which slowed down my progress.",
            "photoGallery": [
                {
                    "url": "media/nebulicious/neb_gameplay.png",
                    "subtitle": "Nebulicious Gameplay"
                },
                {
                    "url": "media/nebulicious/neb_title.png",
                    "subtitle": "Menu UI Design"
                },
                {
                    "url": "media/nebulicious/neb_scriptableObj.png",
                    "subtitle": "Scriptable Object Data Storage"
                },
                {
                    "url": "media/nebulicious/neb_sceneView.png",
                    "subtitle": "Game Scene Setup"
                }
            ],
            "color": "#b19fde"
        },
        {
            "name": "The Shed",
            "description": "A Short Horror Game Made for Aesthetician Lab's 2024 Game Jam in Under 48 Hours.",
            "coverImage": "media/shed/shed.gif",
            "trailerEmbed": "https://www.youtube.com/embed/jucFt8QTxmQ?autoplay=1",
            "icon": "media/shed/shed_icon.jpg",
            "role": "<reg-programmer></reg-programmer> / <game-developer></game-developer>",
            "teamSize": "2",
            "engine": "Unreal Engine 5",
            "tools": "C++, Unreal Engine Blueprints, AWS, Perforce",
            "duration": "June 2024 (2 days)",
            "overview": "The Shed is a short horror game made for Aesthetician Lab's <a href='https://itch.io/jam/exprmt48-2024'>exprmt48 2024 game jam.</a>",
            "goals": [
                "To learn about using C++ in junction with Unreal Engine Blueprints",
                "To create an effective horror game environment in a short time."
            ],
            "responsibilities": "Before the two day development period of The Shed, I prepared a Perforce version control server using Amazon's AWS. Because of this, I can now easily set up new Perforce server instances for future projects without much trouble.<br><n-tab></n-tab>During the game's development, I was in charge of most of the programming and blueprinting. I created a custom C++ first person player script, which limited the player's camera vertical arm movement, allowing for vertical arm movement instead. Along with this, I programmed a custom C++ parent script for all of the interactable objects in the game, giving them destructible properties using Unreal Engine's fracture meshes and various variables to define how loud and durable the objects are. After all player and environmental features were implemented, I created a short tutorial to teach the player the mechanics of the game.",
            "link": "https://ifaicgu.itch.io/the-shed",
            "photoGallery": [
                {
                    "url": "media/shed/shed_gameplay.png",
                    "subtitle": "The Shed Gameplay"
                }
            ],
            "color": "#3d3837"
        },
        {
            "name": "Icarus VR",
            "description": "A Virtual Reality Archery Simulator with Realistic Motions.",
            "coverImage": "media/icarus/icarus.gif",
            "trailerEmbed": "https://www.youtube.com/embed/RV0TUgQLj-Y?autoplay=1",
            "role": "<reg-programmer></reg-programmer> / <game-developer></game-developer>",
            "teamSize": "4",
            "engine": "Unity",
            "tools": "C#, Git, XR dev library, Meta Quest Development Tools, Android Studio, APK Packaging",
            "duration": "January 2023 - May 2023",
            "overview": "Icarus VR is a virtual reality game that has fast-paced gun shooting and skill-based bow and arrow mechanics. Players compete in sky islands, each with its own unique features and challenges. The game offers a variety of game modes, such as Target Frenzy, Quick Draw, Archery, and Flight Archery, each having a leaderboard that stores player data server-side. Icarus offers an immersive exercise experience in virtual reality.<br><n-tab></n-tab>Icarus VR was an exhibit at <a href='https://www.rit.edu/spotlights/world-sports-vr'>RIT's Student Showcase 2023</a> and Imagine RIT 2023.",
            "goals": [
                "To make very immersive controls in virtual reality.",
                "To learn about XR and what it is capable of achieving.",
                "To learn how to build and deploy applications on android devices.",
                "To experiment with storing player data server-side."
            ],
            "responsibilities": "During the development of Icarus VR, my priorities started with developing basic XR interactions, such as picking up objects using the Meta Quest motion-tracking controllers and throwing/letting go of said objects. At first, Icarus was pitched to be a collection of sporting events, including events such as Discus and Javelin Throwing. As such, I developed the throwing physics for Discus and Javelin. This was expedited using the XR Unity library, as well as a Unity plugin that helped visualize the trajectory path of an airborne object. I also implemented math functions that simulate the torque of a discus flying through the air. <br><n-tab></n-tab>Both Discus and Javelin were functionally complete, however, we ultimately decided to scrap them after we saw more engagement from playtesters with our archery game mode. Although my throwing code is no longer used, this gave me a solid understanding of how XR interactions work, which helped me immensely when developing under Xana Ad Hoc Studio for <a href='project.html'  class='project-redir' data-name=`Changeling%VR`>Changeling VR</a>.<n-tab></n-tab> After pivoting to only have an archery game mode, my priorities changed to be focused on scoring, and the storage of player data. I utilized a Unity library for this, allowing me to easily store player scores on a database hosted by the library's owner. I interfaced the database into our Unity project, storing UIDs (Unique Identification Numbers) and metadata for the time that the game was played and how long the game took. I also developed the UI/UX of the leaderboard, allowing users the option to submit their score if they are satisfied with it. I also allowed players to input their names, and utilized a regex algorithm to censor inappropriate words on the leaderboards.<br><n-tab></n-tab>After I finished these tasks with archery, I started working on a new projectile-based game mode, known as Quickshooting. I developed the functionalities of the gun, and a holster that you grab the gun from, which is located on the waist. This ended up being a challenging problem, as I needed to take height differences in players into account when positioning the holster. Thankfully, the Unity XR library had built-in functions that allowed me to measure the height of the player and offset the position of the holster based on the height. After all functionality was complete, I also hooked up the leaderboard functionality to the gamemode, which was relatively simple due to my setting up a flexible system for the archery gamemode.<n-tab></n-tab>Finally, I was tasked to work on one more game mode - an extension of our archery gamemode that allowed the player to fly while shooting their bow. This game mode was supposed to be a new direction for our game in case we were accepted into the MAGIC Maker Program for the Summer of 2023. I worked on gesture recognition, allowing players to fly if they flapped their arms like a bird or held their arms outwards as if they were gliding. To make firing the bow easier in the air, I slowed down tick speed for a short amount of time if the player drew their bow mid-air. Ultimately, this ended up being a technical demo as we were not accepted into the MAGIC Maker Program, however, it was shown off once at Imagine RIT 2023.<br><n-tab></n-tab>Throughout the entire development period of Icarus, I was in charge of building and deploying our builds to the Meta Quest devices, which run Android. I had to learn how to use android studio in conjunction with Unity to create .apk files.",
            "link": "https://sciencedoge.itch.io/icarus-vr",
            "retrospect": "If I were to redo this project, I would make my own database to store player data. Our team was short on time for the leaderboards to be completed, so I was forced to utilize a database created by another individual. Although this database still works, there is no guarantee that it will continue to work into the distant future, and I would have no control if it stopped working. If doing this again today, I would host my own database, store information using SQL, and interface the data with Unity similarly as I do currently.",
            "photoGallery": [
                {
                    "url": "media/icarus/bow.gif",
                    "subtitle": "Archery Gameplay"
                },
                {
                    "url": "media/icarus/gun.gif",
                    "subtitle": "Quickshooting Gameplay"
                },
                {
                    "url": "media/icarus/leaderboard.png",
                    "subtitle": "Leaderboard Display"
                },
                {
                    "url": "media/icarus/flying.gif",
                    "subtitle": "Flight Archery Demo"
                },
                {
                    "url": "media/icarus/javelin-debug.gif",
                    "subtitle": "Debug Example of Javelin Throwing"
                },
                {
                    "url": "media/icarus/discus-physics.gif",
                    "subtitle": "Discus Physics Example"
                }
            ],

            "color": "#99ffff"
        },
        {
            "name": "Doodle Day",
            "description": "üèÜ<b>3rd Place Winner at Wolfjam 2023</b>üèÜ<br>Hackathon Project Made in Under 24 Hours.",
            "coverImage": "media/doodleday/doodleday.gif",
            "role": "<reg-programmer></reg-programmer> / <game-developer></game-developer>",
            "trailerEmbed": "https://www.youtube.com/embed/_gJh6aqzuP8?autoplay=1",
            "icon": "media/doodleday/doodleday_icon.jpg",
            "teamSize": 7,
            "engine": "Unity",
            "tools": "C#, Git",
            "duration": "November 3rd, 2023 - November 4th, 2023",
            "overview": "Doodle Day is a simulation made in 24 hours for the Wolfjam Hackathon 2023. The primary goal of the experience is to use a rubber mallet to defeat aliens that appear on your screen, which look cartoon-ish and make cartoon sound effects. However, there is also a news tab that reveals a darker side of what you are doing, which is affecting life beside you negatively. The game ends as you destroy your own planet, Earth.<br><n-tab></n-tab><a href='https://wolfjam.devpost.com/project-gallery'>The project recieved 3rd place out of 18 teams (14 of which submitted) that participated in the hackathon.</a>",
            "goals": [
                "To complete a successful project in under 24 hours",
                "To communicate effectively with my team and minimize any room for error"
            ],
            "responsibilities": "My main tasks in the 1 day we had to complete this project revolved around the mallet; getting its physics working, and allowing it to interact with entities. The physics of the mallet took most of the first day of development, which was around 4 hours of work. I utilized a spring joint that would attach the mallet to the position where the player clicks or taps the screen. Along with this, I apply torque to the head of the mallet whenever the player starts to drag their finger/mouse in a circular motion. I also allowed users to throw the hammer if they let go while it has a large amount of momentum. Finally, I add a strong force to the hammer (which can destroy entities) whenever the user presses the screen and the hammer isn't nearby. These four aspects, ultimately, made the hammer incredibly engaging to play around with.<br><n-tab></n-tab>The second day of development started with me figuring out how to handle collisions between the mallet and entities, which was not very difficult as I already separated the mallet's hitbox into two separate parts: one for the head and one for the stick. This only required very basic Unity collision checks and a check for velocity to make sure the hammer was moving when it hit an entity. Other than this, I implemented a simple credits sequence at the end of gameplay, which uses <a href='https://oneratgames.itch.io/easycredits'>an asset that I purchased on itch.io</a> to save time, as we only had a few hours left.",
            "retrospect": "If I had another go at this project, I would have made the mallet physics a little bit easier to start up. Currently, it feels as if the mallet is incredibly heavy, which doesn't make too much sense given its toy appearance.",
            "link": "https://prestosilver.itch.io/d-day",
            "photoGallery": [
                {
                    "url": "media/doodleday/doodleday-1.png",
                    "subtitle": "Logo for Doodle Day"
                },
                {
                    "url": "media/doodleday/doodleday-2.png",
                    "subtitle": "Doodle Day Gameplay"
                },
                {
                    "url": "media/doodleday/team.jpg",
                    "subtitle": "Team Workspace at Wolfjaw Studios"
                },
                {
                    "url": "media/doodleday/doodleday-4.png",
                    "subtitle": "News Tab"
                }
            ],
            "color": "#b2cbba"
        },
        {
            "name": "Dark Matter",
            "description": "A 1-Bit Space Shooter Taking Inspiration From Classic Arcade Games.",
            "coverImage": "media/darkmatter/darkmatter.gif",
            "trailerEmbed": "https://www.youtube.com/embed/OlgM1a4RoXk?autoplay=1",
            "role": "<reg-programmer> </reg-programmer> / <game-developer></game-developer>",
            "teamSize": "2",
            "engine": "N/A",
            "tools": "C++, raylib, gdb, Git, Aseprite, .bat files",
            "duration": "August 2023",
            "overview": "Dark Matter is a 1-bit space shooter game made in a week for the <a href='https://itch.io/jam/1-bit-jam-wow'>1-BIT 2023 Game Jam</a>. The project is made primarily in C++ and uses the raylib library for development support. The game is a simple 'shoot-em-up' game, where you control a spaceship that can use light to defeat oncoming enemies. However, whenever the player shoots, some of their light is sacrificed. When the player has no more light, it is game over. Dark Matter garnered much attention during the period of the jam, having over 60 ratings and being the fourth most rated game.",
            "goals": [
                "To create a game from scratch in C++",
                "To challenge my design senses by only allowing two colors at once",
                "To improve my C++ / stdlib knowledge"
            ],
            "responsibilities": "During the two week period of the jam, my main responsibilities were to implement player and enemy mechanics. I first started with the player, and implemented a simple update/draw loop to register player movement and draw the player every frame.<br><n-tab></n-tab>I then created functionality for the player shooting their 'light beams' by creating a projectile class (which is a parent class for both player and enemy bullets). The projectiles are pooled by pre-spawning them, and are moved to the player's shoot position whenever the 'shoot' action is called. The projectiles use similar velocity code to the player, and are not destroyed from memory until after the game ends. I then created simple player information, such as health points, which is connnected to the player's projectiles (health will proportionately fall based on number of projectiles shot, and will increase based on health pickups gathered). <br><n-tab></n-tab>After all of the player functionality was complete, I realized how many entities would need to be kept track of in the game, so I created a centralized list data structure that holds all entities in the game, as every spawnable object is derived from the same parent class. This ultimately helped me with spawn pooling and keeping track of entity memory when debugging.<br><n-tab></n-tab> After this, I started working on enemies and their spawning patterns. Due to the time limits of the game jam, I decided to only make one kind of enemy, however, I could customize this one enemy with different bullet patterns, trajectory paths, and speeds. I created a system that allowed us to procedurally generate different enemy paths based on number of enemies, spacing of enemies, number of loops the enemies would take, where enemies would start and end, etc. Because of this, every playthrough of Dark Matter is unique in terms of how enemies spawn.<br><n-tab></n-tab>One of the biggest design considerations I had to deal with for players and enemies were the colors of their projectiles. At first, I treated the projectiles of the players and enemies the same, visually and mechanically, however, it quickly became harder to differentiate which projectiles could hurt the player as more filled the screen. To circumvent this, I created a new sprite for enemy bullets, and removed their VFX to make them look more discernible.<br><n-tab></n-tab>After completing player and enemy mechanics, I worked on the UI for the main menu, main game state, and pause menu. These were relatively easy to construct, with the only major problem being canvas scaling (which was completed with a bit of math). I wanted to have the UI resemble classic space shooters, so I employed a two column approach, having the game on one side of the screen and game statistics on the other.<br></n-tab>For debugging purposes, I used gdb in the console whenever I encountered a crash in the executable. This, usually, helped me determine exactly where in the code a fault was happening, which saved a ton of development time. ",
            "retrospect": "If I had the chance to redo this project, I would have expanded more upon the 'light health' mechanic. Currently, the only purpose of the light is a visual indicator of player and enemy HP, with the twist that shooting takes away a bit of light from the player. I wish this mechanic played a more pivotal role; potentially affecting the vision of the player or affecting the projectiles of the enemies the same way our black hole does. Along with this, I wish I documented my code a bit more than I did. Going back through the repository to write this retrospective made it clear that I didn't take much care to comment my code (mostly due to the time constraints). This ultimately made it difficult for me to understand the thought processes I had during this time period.",
            "link": "https://prestosilver.itch.io/dark-matter",
            "photoGallery": [
                {
                    "url": "media/darkmatter/darkmatter_title.png",
                    "subtitle": "Dark Matter Title Screen"
                },
                {
                    "url": "media/darkmatter/darkmatter1.png",
                    "subtitle": "Dark Matter Gameplay"
                },
                {
                    "url": "media/darkmatter/darkmatter3.png",
                    "subtitle": "Light Beam"
                },
                {
                    "url": "media/darkmatter/darkmatter2.png",
                    "subtitle": "Dark Matter Boss Fight"
                },
                {
                    "url": "media/darkmatter/darkmatter_pause.png",
                    "subtitle": "Dark Matter Pause Screen"
                }
            ],
            "color": "#d28264"
        },
        {
            "name": "Helpless",
            "description": "A Game Tribute to the Art Piece 'Can't Help Myself'.<br>Made in under 2 weeks for the Pirate Software Jam 2024.",
            "coverImage": "media/helpless/helpless.gif",
            "trailerEmbed": "https://www.youtube.com/embed/K0Y8g-00aNE?autoplay=1",
            "icon": "media/helpless/helpless_icon.png",
            "role": "<reg-programmer></reg-programmer> / <game-developer></game-developer>",
            "duration": "Winter 2024 (2 weeks)",
            "engine": "Unity",
            "teamSize": "5",
            "tools": "C#, Unity, Git, Blender, Unity Shader Graph",
            "overview": "Helpless is a gamified representation of the 'Can't Help Myself' artpiece at the Guggenheim in New York City. It was created for the Pirate Software Winter Game Jam 2024, with the theme being 'It Spreads'. The player plays as a robot with one objective - to keep all of its oil within itself. The oil seeps out of the robot constantly, and the only way to regain it is to scoop it back in manually. When the player runs out of oil, the game ends.",
            "docs": "https://docs.google.com/document/d/18OGNfsIwT99Oo75fd28T4Td8Qt6gd3dOsU3-HkybI4U/edit",
            "goals": [
                "To get our development team's name some recognition",
                "To challenge myself with a side project while focusing mostly on <a href='project.html'  class='project-redir' data-name=`Ninjas%on%Trampolines`>Ninjas on Trampolines</a>"
            ],
            "responsibilities": "During the two weeks I had to work on the game, most of the development time was spend during weekends, and right before submissions were due. This is because I was working full-time on <a href='project.html'  class='project-redir' data-name=`Ninjas%on%Trampolines`>Ninjas on Trampolines</a>, and had no time to spare during the weekdays.<br><n-tab></n-tab> That being said, I was tasked to work on the fluid physics and interactions, including spawning, spreading, and pushing in the machine's oil. The oil is comprised out of many sphere colliders that have a shader attached to them to make them look as if they are blending together. A separate render texture is used to achieve this effect, masking out the area of the oil and applying the shader effect to it.<br><n-tab></n-tab>Getting the oil to scoop back into the machine was a simple process - I just needed to increase the linear drag of each particle to ensure they couldn't slip past the machine's claw. I attached a large collider to the tip of the player's machine that only collides with oil particles, which worked perfectly.<br><n-tab></n-tab>After getting the oil fluids working, I was tasked to work on some background assets for the scene to help the load of work given to our artist. I constructed the plants and the golden museum blockers in the 3D modelling software Blender.<br><n-tab></n-tab>Then, I was tasked to create a 'litter' system in the game, in which the museum guests would throw trash into the exhibit when they were not entertained. The throwing logic was the toughest step in this, as I needed to use some trigonometry with a starting velocity to accurately predict the trajectory for the trash to meet its destination.<br><n-tab></n-tab>Finally, I worked on the tutorial logic at the beginning of the game, constructing a dialogue system using a list of structs. I also created logic for the players to skip through text, in case they have seen the tutorial before. ",
            "retrospect": "If I had the time to revisit this project, I would add more realistic physics to the oil. I hadn't thought to experiment with variables such as viscosity when creating the oil, which I feel would have added an extra sense of realism.",
            "link": "https://ifaicgu.itch.io/helpless",
            "photoGallery": [
                {
                    "url": "media/helpless/helpless-menu.png",
                    "subtitle": "Helpless Main Menu"
                },
                {
                    "url": "media/helpless/helpless-tutorial.png",
                    "subtitle": "Helpless Tutorial"
                },
                {
                    "url": "media/helpless/helpless-game.png",
                    "subtitle": "Helpless Gameplay"
                },
                {
                    "url": "media/helpless/helpless-gameover.png",
                    "subtitle": "Helpless Game Over"
                }
            ],
            "color": "#bfc4d0"
        },
        {
            "name": "Myne Graphics Engine",
            "description": "A 2D/3D Graphics, Audio, and Physics Engine Using C++ and OpenGL.",
            "coverImage": "media/myne/myne.gif",
            "trailerEmbed": "https://www.youtube.com/embed/mnMgia8DV6g?autoplay=1",
            "role": "<reg-programmer> </reg-programmer>",
            "duration": "2022 - Present",
            "teamSize": 1,
            "tools": "C++, gdb, Git, OpenAL, FreeType, OpenGL, GLFW, GLM, imGUI, RenderDoc",
            "overview": "Myne Graphics Engine is a game engine that fully supports rendering 2D bitmaps and glyphs, 3D models with lighting, playing back .wav files, and performing physics calculations between objects via the built-in math functions. It is programmed in pure C++, using OpenGL and OpenAL for visual and auditory functionalities. Myne has been a personal project of mine, with the hopes of someday using the engine to make a game.",
            "goals": [
                "To improve my knowledge of C++ and graphics programming",
                "To create an engine that I have full freedom over"
            ],
            "responsibilities": "I was the sole developer of this project, meaning I programmed everything that is available in this engine. I referenced other public repositories and <a href='https://learnopengl.com/'>this helpful OpenGL tutorial series</a> when constructing the engine. The current iteration of Myne on my github is actually a rewrite of <a href='https://github.com/scc8371/Myne-Engine'>my first engine</a>, which had many bugs and code that needed to be reworked.<br><n-tab></n-tab>When I first started the engine, I created simple 2D rendering functionality, using basic GLFW setup code and a fragment/vertex shader. This allowed me to render basic triangles/squares to the screen. From there, I added functionality from OpenGL to parse textures, which was passed into the shaders during draw calls. I often utilize a piece of software called <a href='https://renderdoc.org/'>RenderDoc</a> to help debug texture and UV issues.<br><n-tab></n-tab>After finishing basic texture rendering, I created sprite batching functionality, which sends texture data through a <a href='https://en.wikipedia.org/wiki/Fletcher%27s_checksum'>Fletcher-16 checksum function</a>. The data is consequently sent to a queue data structure, where it houses the data and sends all texture information to the GPU in a single call. This significantly reduced the number of GPU calls when rendering textures, optimizing the process.<br><n-tab></n-tab>When I wrapped up 2D rendering, I started work on audio using OpenAL. This was likely the hardest part of creating the engine for me, as I remember having so many errors from OpenAL when trying to read in audio. I created my own WAV parser which would read in chunks of bytes from a WAV file, in hopes to find sections of data that the engine can play back. I eventually nailed the chunk order of WAV files, however, it took at least a week for everything to work properly. When audio playback started to work, I added functionality to loop audio tracks, and start audio loops from a certain loop point in the song. Along with this, I added various pitch and volume settings that can be controlled using variables.<br><n-tab></n-tab>After this was complete, I worked on glyph parsing using FreeType to allow for fonts to be rendered. I had to make a separate fragment shader for fonts, as the fragment colors for the font files were in a different format. Reading in font files with FreeType was similar to reading in .wav files, as i had to read in chunks that held information about the font. To display font, I allow users to call a 'draw' function that requires a character array, a location on screen, and a color. Each character in the array is looped through and given a glyph value from the parser, which is stitched together and given appropriate UV colors. The text sprite is then given to my spritebatch, which is sent to the GPU at the next draw call.<br><n-tab></n-tab>The final feature I added for 2D was a custom math library that supported vectors, vector math, simple bounding colliders, color definitions, and axis definitions. These are to be used instead of glm when constructing a game using the engine to simplify the process.<br><n-tab></n-tab>Recently, I have been trying to expand Myne to have 3D functionality. I have made simple mesh rendering capabilities, with the ability to load in .obj files and view a mesh with simple lighting. I plan to continue working on this, improving lighting and material capabilities. <br><n-tab></n-tab>Going forward, I am going to continue working on 3D functionality, expanding upon my math utilities by adding quaternions and 3D vectors, along with adding an entity component system (ECS) to make entities easier to manage. Along with this, I plan to write documentation that explains how to use the engine.",
            "link": "https://github.com/scc8371/DiMyne-Engine",
            "photoGallery": [
                {
                    "url": "media/myne/cube.gif",
                    "subtitle": "Myne 3D Functionality Demo"
                }
            ],
            "color": "#4fbcb4"
        },
        {
            "name": "Audio Visualizer",
            "description": "A Web Application That Visualizes Audio Frequencies. ",
            "coverImage": "media/visualizer/visualizer.gif",
            "trailerEmbed": "https://www.youtube.com/embed/bI0-IUr1g7M?autoplay=1",
            "role": "<reg-programmer></reg-programmer>",
            "duration": "Spring 2023",
            "tools": "HTML, CSS, JavaScript, datGUI, JavaScript canvas, JavaScript web audio",
            "overview": "This is an audio visualizer I created using JavaScript's canvas and web audio APIs. The controls of the application were integrated through the datgui library. This project was created in hopes to give users as much freedom as possible, letting them customize how the visualizer works in several different aspects. It features a spinning sphere that is constructed from lines using the javascript canvas API. The sphere is distorted with a combination of perlin noise and audio wave frequencies whenever a song starts playing.",
            "goals": [
                "To improve my knowledge of web development",
                "To challenge myself with implementing 3D math in a 2D canvas library",
                "To learn more about manipulating audio data and displaying it visually"
            ],
            "responsibilities": "I was the sole developer of this project and developed every feature. Most of the 3D math that I used to produce the sphere came from a 3D math class I was taking at the time, so I referenced what I had done in C++ and converted it into JavaScript code. The sphere math calculates points that are projected about the user's perspective, given a radius and the number of segments to be generated horizontally and vertically. The point data is then stored in a cache and reused until the points need to be regenerated, which saves on some computational power. Since the javascript canvas is meant for 2D drawing, drawing a 3D sphere within it is not very fast, which is why I needed to store a cache and do other various optimizations to ensure a semi-smooth frame rate.<br><n-tab></n-tab>The GUI of the application holds every customization tool that users can use. Firstly, audio data of the visualizer can be visually changed between frequency and waveform data. Displaying frequency data is more stable in this simulation, as I could utilize different sections of the data (the treble, bass, etc.) to control specific parts of the sphere. Waveform data more so represents the shape of the audio wave, and cannot be as easily manipulated. Along with audio data settings, I have various visual settings, including the ability to change the colors of the sphere and background. This data is stored and updated in draw calls when filling in the quads of the sphere (or the gradient in the background). Also, I have several filters that can invert, emboss, or ignore the fill draw calls on the sphere (wire frame mode). These filters are applied by manipulating the color values of each pixel on the canvas, running math functions on the RGB(A) values to change their values.",
            "retrospect": "If I were to do this project again, I would use a JavaScript library that is more suited for rendering 3D models, like <a href='https://threejs.org/'>three.js</a>. Along with this, I would smooth the noise movement a bit, likely using linear interpolation, as I've gotten feedback that the jitteryness of the sphere makes it look uncanny.",
            "link": "visualizer/index.html",
            "photoGallery": [
                {
                    "url": "media/visualizer/frequency.gif",
                    "subtitle": "Frequency Data Visualizer"
                },
                {
                    "url": "media/visualizer/waveform.gif",
                    "subtitle": "Waveform Data Visualizer"
                },
                {
                    "url": "media/visualizer/noise.gif",
                    "subtitle": "High Perlin Noise Demonstration"
                },
                {
                    "url": "media/visualizer/settings.gif",
                    "subtitle": "Settings Demonstration"
                }
            ],
            "color": "#01d004"
        },
        {
            "name": "Roll Arena 64",
            "description": "A Dice Rolling Puzzle Game Made For the GMTK Game Jam 2022.",
            "coverImage": "media/rollarena/rollarena.gif",
            "trailerEmbed": "https://www.youtube.com/embed/z6m6COi9G5M?autoplay=1",
            "icon": "media/rollarena/rollarena_icon.png",
            "role": "<reg-programmer> </reg-programmer> / <game-developer></game-developer>",
            "teamSize": "2",
            "duration": "Summer 2022 (2 days)",
            "engine": "Unity",
            "tools": "C#, Git, Blender",
            "overview": "Roll Arena 64 is a 3D Unity prototype created in the span of 2 days for the GMTK Game Jam 2022. Players control a blue dice and can roll onto different sides, each representing a pattern that is drawn on the floor. The objective of the game is to have the most of your color on the floor before the round counter reaches zero. Roll Arena garnered a successful rating during the jam, just missing a top 1000 placement out of over 6000 entries.",
            "goals": [
                "To see how much I have improved as a developer since my previous submission in 2021",
                "To improve my knowledge of Unity/C# development",
                "To experiment with the puzzle game genre"
            ],
            "responsibilities": "During the short development of Roll Arena 64, I was tasked with implementing player movement, tile recognition, as well as the AI for opponents. <br><n-tab></n-tab>I started with setting up the grid, creating a 16x16 area where each node stored if it was being traversed on, as well as the color of it. This would be used later when calculating score, and determining where a player can move. After this, I set up a basic player object and programmed simple movement code for it. Then, after we set up logic that correlated a side of the player's die with a pattern, I wrote logic that would check said pattern and traverse the nodes on the ground to paint that pattern. The player was functionally complete at that point.<br><n-tab></n-tab>To complete the game loop, I then needed to work on enemies and their AI. Functionally, they would act the exact same as the player, so most of my code worked perfectly in that regard. However, I needed to figure out an algorithm that would allow the computer opponents to make their own moves. I came up with a solution of using a depth first search algorithm with weights. Empty nodes or nodes of another player's color would be given a higher weight than nodes of the moving opponent's color. This worked as expected, and opponents were able to make efficient moves.",
            "retrospect": "If I did this project again, I would make the enemy AI less perfect. Currently, the enemies try to make the best possible moves with their logic. If I were to redo this AI, I would sometimes make the enemies take the second or third best move they can. Along with this, the movement of computers are incredibly slow. I would half or quarter the amount time it takes to complete a computer turn.",
            "link": "https://prestosilver.itch.io/ra64",
            "photoGallery": [
                {
                    "url": "media/rollarena/rollarena1.jpg",
                    "subtitle": "Player's turn"
                },
                {
                    "url": "media/rollarena/rollarena2.jpg",
                    "subtitle": "Title Screen"
                },
                {
                    "url": "media/rollarena/rollarena3.png",
                    "subtitle": "Complete Game Board"
                }
            ],
            "color": "#e1d59b"
        },
        {
            "name": "Bottle Knights!",
            "description": "A 2D Web idle game made in JavaScript and pixi.JS",
            "coverImage": "media/bottleknights/bottleknights.gif",
            "trailerEmbed": "https://www.youtube.com/embed/WR9k8mJyouc?autoplay=1",
            "role": "<reg-programmer> </reg-programmer> / <game-developer></game-developer>",
            "teamSize": "1",
            "tools": "HTML, CSS, JavaScript, pixi.js, Howler.js, JavaScript canvas",
            "overview": "Bottle Knights is a 2D Web Idle game developed from scratch in JavaScript and the pixi.JS library. The player interacts with the game by pressing buttons located on the browser DOM to upgrade their character and gain bonuses that last until the end of the game.",
            "duration": "Spring 2022 (around 2 weeks)",
            "goals": [
                "To create a web-based game using JavaScript, HTML, and CSS",
                "To apply my knowledge of web development"
            ],
            "responsibilities": "This was a solo project, and one of the first applications that I made for the web. It utilizes the browser DOM and the JavaScript canvas to create an 'auto-battler' type game. I did not use an engine to create this game, only the pixi.js library to help with rendering graphics; all of the update/drawing loops were done manually by me.<br><n-tab></n-tab>I programmed all of the player and enemy mechanics by scratch using JavaScript classes, including statistics and powerups. Along with this, I created a 'shop' system to upgrade the player using a currency gained by killing enemies.<br><n-tab></n-tab>To top everything off, I created functionality for sprite animation, created UI for the players and enemies, and implemented a 'boss' that the player can fight to end the game. Everything done for this project was created in the span of about two weeks, submitted as the final project for my first web development university course.<br><n-tab></n-tab>This was my first larger project in web development, and although I've grown my skills much since, I am still proud of how much I was able to get done in a short amount of time.",
            "link": "bottle-knights/index.html",
            "photoGallery": [
                {
                    "url": "media/bottleknights/playerCustomization.png",
                    "subtitle": "Player Customization Menu"
                },
                {
                    "url": "media/bottleknights/gameplay.png",
                    "subtitle": "Bottle Knights Gameplay"
                },
                {
                    "url": "media/bottleknights/boss.png",
                    "subtitle": "Bottle Knights Boss Fight"
                },
                {
                    "url": "media/bottleknights/victory.png",
                    "subtitle": "Victory Screen!"
                }
            ],
            "retrospect": "If I did this project again, I would store all entity data in a better format, likely in a conjoined list. Along with this, I liked the idea of having DOM elements as controls back then, however, it created more problems than what it was worth. I would likely have the entire game be canvas based, including controls.",
            "color": "#c14a34"
        },
        {
            "name": "Karnissa's Castle",
            "description": "A 3D Puzzle Game Taking Inspiration From the World of Ethshar.",
            "coverImage": "media/karnissascastle/karnissa.gif",
            "trailerEmbed": "https://www.youtube.com/embed/ZeVq3YvQDkc?autoplay=1",
            "role": "<reg-programmer> </reg-programmer> / <game-developer></game-developer>",
            "duration": "Fall 2022",
            "engine": "Unity",
            "teamSize": 5,
            "tools": "C#, Git",
            "docs": "https://docs.google.com/document/d/1P3KcDAdQa1v-NOjD_mr9sq251YVQHOqY4gmywvk-WpU/edit",
            "overview": "Karnissa's Castle is a 3D puzzle game created in Unity, inspired by the World of Ethshar book series. The fundamental mechanics of the game revolve around switching between two characters to solve one puzzle. The game was inspired from the flash game series 'Fire Boy and Water Girl', taking a 3D twist on its core puzzle solving mechanics.",
            "goals": [
                "To make a larger-scale project in Unity",
                "To get used to working in a team-based setting"
            ],
            "responsibilities": "I did most of the programming for Karnissa's Castle, including the puzzle mechanics and player interactions. I constructed several different puzzle components, such as levers, pressure-plates, cauldrons, potions, doors, and boulders.<br><n-tab></n-tab>Most of the puzzle components were straight forward - whenever a player would interact with it, it sends out an event to any of its listeners. If a condition is met, then the puzzle is solved. Most of the development time was spent on perfecting the cauldron/potion system. I ended up using a custom hash map data structure to hold all of the recipes and solutions to said recipes. This was a simple solution to this problem, giving us flexibility to add or destroy new potions in the matter of minutes.<br><n-tab></n-tab>Other than general puzzle mechanics, I designed and constructed the puzzles of the first two chambers in the game. These are designed to allow players to learn the basic puzzle mechanics before trying the more complex chambers.",
            "retrospect": "This was my first bigger game that I made in Unity, and I am happy with how it turned out. However, if I did this project again, I would find a better way to store recipe and player save data. As it is constructed currently, each cauldron needed to be manually populated with each recipe. Nowadays, I would have likely created an external file (JSON) that held all of this information. Along with this, players need to restart the entire game if they return to the menu. I would have some sort of basic saving system that would save the level the player left on, in case they wanted to play again.",
            "link": "https://sciencedoge.itch.io/karnissas-castle",
            "photoGallery": [
                {
                    "url": "media/karnissascastle/karnissa1.png",
                    "subtitle": "Level Ending"
                },
                {
                    "url": "media/karnissascastle/karnissa2.png",
                    "subtitle": "Puzzle Script"
                },
                {
                    "url": "media/karnissascastle/karnissa3.png",
                    "subtitle": "Lever Puzzle"
                }
            ],
            "color": "#dbd8df"
        }
    ]
}